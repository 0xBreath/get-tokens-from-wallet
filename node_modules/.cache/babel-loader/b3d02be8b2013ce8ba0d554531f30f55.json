{"ast":null,"code":"var _jsxFileName = \"/Users/drewriester/Coding/Solana/upgrade-nft/src/Home.tsx\",\n    _s = $RefreshSig$();\n\nimport styled from \"styled-components\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ConnectButton = styled(WalletDialogButton)``;\n_c = ConnectButton;\n\nfunction Home(props) {\n  _s();\n\n  const wallet = useAnchorWallet();\n\n  if (wallet) {\n    /*#__PURE__*/\n    _jsxDEV(ConnectButton, {\n      children: \"Connect Wallet\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 263,\n      columnNumber: 5\n    }, this);\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: !wallet ? /*#__PURE__*/_jsxDEV(ConnectButton, {\n      children: \"Nope\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 268,\n      columnNumber: 20\n    }, this) : 1\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 267,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Home, \"LXWEF/NtXbFn+/uJYraKGQdvW1I=\", false, function () {\n  return [useAnchorWallet];\n});\n\n_c2 = Home;\nexport default Home;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"ConnectButton\");\n$RefreshReg$(_c2, \"Home\");","map":{"version":3,"sources":["/Users/drewriester/Coding/Solana/upgrade-nft/src/Home.tsx"],"names":["styled","useAnchorWallet","WalletDialogButton","ConnectButton","Home","props","wallet"],"mappings":";;;AACA,OAAOA,MAAP,MAAmB,mBAAnB;AASA,SAASC,eAAT,QAAgC,8BAAhC;AACA,SAASC,kBAAT,QAAmC,oCAAnC;;AAoPA,MAAMC,aAAa,GAAGH,MAAM,CAACE,kBAAD,CAAqB,EAAjD;KAAMC,a;;AAEN,SAASC,IAAT,CAAeC,KAAf,EAAiC;AAAA;;AAE/B,QAAMC,MAAM,GAAGL,eAAe,EAA9B;;AAEA,MAAIK,MAAJ,EAAY;AACV;AAAA,YAAC,aAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACD;;AAED,sBACE;AAAA,cACI,CAACA,MAAD,gBAAW,QAAC,aAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAX,GAAoD;AADxD;AAAA;AAAA;AAAA;AAAA,UADF;AAKD;;GAbQF,I;UAEQH,e;;;MAFRG,I;AAgBT,eAAeA,IAAf","sourcesContent":["import { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport Countdown from \"react-countdown\";\nimport { Button, CircularProgress, Snackbar } from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\n\nimport * as anchor from \"@project-serum/anchor\";\n\nimport { LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\n\nimport Meta from './metadata/getMeta'\n\n\nimport {\n  CandyMachine,\n  awaitTransactionSignatureConfirmation,\n  getCandyMachineState,\n  mintOneToken,\n  shortenAddress,\n} from \"./candy-machine\";\n\n/*\nconst ConnectButton = styled(WalletDialogButton)``;\n\nconst CounterText = styled.span``; // add your styles here\n\nconst MintContainer = styled.div``; // add your styles here\n\nconst MintButton = styled(Button)``; // add your styles here\n\nexport interface HomeProps {\n  candyMachineId: anchor.web3.PublicKey;\n  config: anchor.web3.PublicKey;\n  connection: anchor.web3.Connection;\n  startDate: number;\n  treasury: anchor.web3.PublicKey;\n  txTimeout: number;\n}\n\nconst Home = (props: HomeProps) => {\n  const [balance, setBalance] = useState<number>();\n  const [isActive, setIsActive] = useState(false); // true when countdown completes\n  const [isSoldOut, setIsSoldOut] = useState(false); // true when items remaining is zero\n  const [isMinting, setIsMinting] = useState(false); // true when user got to press MINT\n\n  const [itemsAvailable, setItemsAvailable] = useState(0);\n  const [itemsRedeemed, setItemsRedeemed] = useState(0);\n  const [itemsRemaining, setItemsRemaining] = useState(0);\n\n  const [alertState, setAlertState] = useState<AlertState>({\n    open: false,\n    message: \"\",\n    severity: undefined,\n  });\n\n  const [startDate, setStartDate] = useState(new Date(props.startDate));\n\n  const wallet = useAnchorWallet();\n\n  const [candyMachine, setCandyMachine] = useState<CandyMachine>();\n\n  const refreshCandyMachineState = () => {\n    (async () => {\n      if (!wallet) return;\n\n      const {\n        candyMachine,\n        goLiveDate,\n        itemsAvailable,\n        itemsRemaining,\n        itemsRedeemed,\n      } = await getCandyMachineState(\n        wallet as anchor.Wallet,\n        props.candyMachineId,\n        props.connection\n      );\n\n      setItemsAvailable(itemsAvailable);\n      setItemsRemaining(itemsRemaining);\n      setItemsRedeemed(itemsRedeemed);\n\n      setIsSoldOut(itemsRemaining === 0);\n      setStartDate(goLiveDate);\n      setCandyMachine(candyMachine);\n    })();\n  };\n\n  const onMint = async () => {\n    try {\n      setIsMinting(true);\n      if (wallet && candyMachine?.program) {\n\n        const mintTxId = await mintOneToken(\n          candyMachine,\n          props.config,\n          wallet.publicKey,\n          props.treasury\n        );\n\n        const status = await awaitTransactionSignatureConfirmation(\n          mintTxId,\n          props.txTimeout,\n          props.connection,\n          \"singleGossip\",\n          false\n        );\n\n        if (!status?.err) {\n          setAlertState({\n            open: true,\n            message: \"Congratulations! Mint succeeded!\",\n            severity: \"success\",\n          });\n        } else {\n          setAlertState({\n            open: true,\n            message: \"Mint failed! Please try again!\",\n            severity: \"error\",\n          });\n        }\n      }\n    } catch (error: any) {\n      // TODO: blech:\n      let message = error.msg || \"Minting failed! Please try again!\";\n      if (!error.msg) {\n        if (error.message.indexOf(\"0x138\")) {\n        } else if (error.message.indexOf(\"0x137\")) {\n          message = `SOLD OUT!`;\n        } else if (error.message.indexOf(\"0x135\")) {\n          message = `Insufficient funds to mint. Please fund your wallet.`;\n        }\n      } else {\n        if (error.code === 311) {\n          message = `SOLD OUT!`;\n          setIsSoldOut(true);\n        } else if (error.code === 312) {\n          message = `Minting period hasn't started yet.`;\n        }\n      }\n\n      setAlertState({\n        open: true,\n        message,\n        severity: \"error\",\n      });\n    } finally {\n      if (wallet) {\n        const balance = await props.connection.getBalance(wallet.publicKey);\n        setBalance(balance / LAMPORTS_PER_SOL);\n      }\n      setIsMinting(false);\n      refreshCandyMachineState();\n    }\n  };\n\n  useEffect(() => {\n    (async () => {\n      if (wallet) {\n        const balance = await props.connection.getBalance(wallet.publicKey);\n        setBalance(balance / LAMPORTS_PER_SOL);\n      }\n    })();\n  }, [wallet, props.connection]);\n\n  useEffect(refreshCandyMachineState, [\n    wallet,\n    props.candyMachineId,\n    props.connection,\n  ]);\n\n  return (\n    <main>\n      {wallet && (\n        <p>Wallet {shortenAddress(wallet.publicKey.toBase58() || \"\")}</p>\n      )}\n\n      {wallet && <p>Balance: {(balance || 0).toLocaleString()} SOL</p>}\n\n      {wallet && <p>Total Available: {itemsAvailable}</p>}\n\n      {wallet && <p>Redeemed: {itemsRedeemed}</p>}\n\n      {wallet && <p>Remaining: {itemsRemaining}</p>}\n\n\n      <MintContainer>\n        {!wallet ? (\n          <ConnectButton>Connect Wallet</ConnectButton>\n        ) : (\n          <MintButton\n            disabled={isSoldOut || isMinting || !isActive}\n            onClick={onMint}\n            variant=\"contained\"\n          >\n          \n            {Meta(wallet.publicKey)}\n\n            {isSoldOut ? (\n              \"SOLD OUT\"\n            ) : isActive ? (\n              isMinting ? (\n                <CircularProgress />\n              ) : (\n                \"MINT\"\n              )\n            ) : (\n              <Countdown\n                date={startDate}\n                onMount={({ completed }) => completed && setIsActive(true)}\n                onComplete={() => setIsActive(true)}\n                renderer={renderCounter}\n              />\n            )}\n          </MintButton>\n        )}\n      </MintContainer>\n\n      <Snackbar\n        open={alertState.open}\n        autoHideDuration={6000}\n        onClose={() => setAlertState({ ...alertState, open: false })}\n      >\n        <Alert\n          onClose={() => setAlertState({ ...alertState, open: false })}\n          severity={alertState.severity}\n        >\n          {alertState.message}\n        </Alert>\n      </Snackbar>\n    </main>\n  );\n};\n\ninterface AlertState {\n  open: boolean;\n  message: string;\n  severity: \"success\" | \"info\" | \"warning\" | \"error\" | undefined;\n}\n\nconst renderCounter = ({ days, hours, minutes, seconds, completed }: any) => {\n  return (\n    <CounterText>\n      {hours + (days || 0) * 24} hours, {minutes} minutes, {seconds} seconds\n    </CounterText>\n  );\n};\n*/\n\nexport interface HomeProps {\n  connection: anchor.web3.Connection;\n}\n\nconst ConnectButton = styled(WalletDialogButton)``;\n\nfunction Home (props: HomeProps) {\n\n  const wallet = useAnchorWallet();\n\n  if (wallet) {\n    <ConnectButton>Connect Wallet</ConnectButton>\n  }\n\n  return (\n    <div>\n      { !wallet ? (<ConnectButton>Nope</ConnectButton>) : ( 1 ) }\n    </div>\n  )\n}\n\n\nexport default Home\n"]},"metadata":{},"sourceType":"module"}
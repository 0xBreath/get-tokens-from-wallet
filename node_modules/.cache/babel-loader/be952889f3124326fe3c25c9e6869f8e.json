{"ast":null,"code":"import { programs } from '@metaplex/js/';\nimport { PublicKey, Connection } from '@solana/web3.js';\nconst {\n  metadata: {\n    MetadataData\n  },\n  TokenAccount\n} = programs;\nexport const fetchNFTsOwnedByWallet = async userWallet => {\n  var _nftAcInfo;\n\n  //Establishes Connection\n  const connection = new Connection(\"https://api.devnet.solana.com/\"); // Gets array of token account objects\n\n  const accounts = await TokenAccount.getTokenAccountsByOwner(connection, userWallet); // Isolate accounts with a positive balance\n\n  const accountsWithAmount = accounts.map(_ref => {\n    let {\n      data\n    } = _ref;\n    return data;\n  }).filter(_ref2 => {\n    let {\n      amount\n    } = _ref2;\n    return (amount === null || amount === void 0 ? void 0 : amount.toNumber()) > 0;\n  }); // Fetches mint address within token account\n\n  let nftMintAddresses = accountsWithAmount.map(_ref3 => {\n    let {\n      mint\n    } = _ref3;\n    return mint;\n  });\n  let nftMetadataAddresses = [];\n  let nftAcInfo; // Loop thru array of token mint addresses\n\n  for (let i = 0; i < nftMintAddresses.length; i++) {\n    // Gets PDA (metadata address) for each token account\n    nftMetadataAddresses[i] = await fetchMetadata(nftMintAddresses[i]); // Gets Account object from PDA (metadata address)\n    // getMultipleAccountsInfo handles an array of Accounts\n\n    nftAcInfo = await connection.getMultipleAccountsInfo(nftMetadataAddresses, \"processed\");\n  }\n\n  let nftAcInfoDeserialized = (_nftAcInfo = nftAcInfo) === null || _nftAcInfo === void 0 ? void 0 : _nftAcInfo.map(info => (info === null || info === void 0 ? void 0 : info.data) !== undefined ? MetadataData.deserialize(info === null || info === void 0 ? void 0 : info.data) : undefined).filter(function (element) {\n    return element !== undefined;\n  });\n  console.log(nftAcInfoDeserialized);\n  return nftAcInfoDeserialized;\n};\nexport async function fetchMetadata(nftMintKey) {\n  const metadataBuffer = Buffer.from('metadata');\n  const metadataProgramIdPublicKey = new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'); // Fetches metadata account from PDA\n\n  const metadataAccount = (await PublicKey.findProgramAddress([metadataBuffer, metadataProgramIdPublicKey.toBuffer(), nftMintKey.toBuffer()], metadataProgramIdPublicKey))[0];\n  console.log(metadataAccount);\n  return metadataAccount;\n}","map":{"version":3,"sources":["/Users/drewriester/Coding/Solana/upgrade-nft/src/components/fetchMeta.ts"],"names":["programs","PublicKey","Connection","metadata","MetadataData","TokenAccount","fetchNFTsOwnedByWallet","userWallet","connection","accounts","getTokenAccountsByOwner","accountsWithAmount","map","data","filter","amount","toNumber","nftMintAddresses","mint","nftMetadataAddresses","nftAcInfo","i","length","fetchMetadata","getMultipleAccountsInfo","nftAcInfoDeserialized","info","undefined","deserialize","element","console","log","nftMintKey","metadataBuffer","Buffer","from","metadataProgramIdPublicKey","metadataAccount","findProgramAddress","toBuffer"],"mappings":"AAAA,SAAUA,QAAV,QAA0B,eAA1B;AACA,SAASC,SAAT,EAAoBC,UAApB,QAAsC,iBAAtC;AAGA,MAAM;AACFC,EAAAA,QAAQ,EAAE;AAAEC,IAAAA;AAAF,GADR;AAEFC,EAAAA;AAFE,IAGFL,QAHJ;AAKA,OAAO,MAAMM,sBAAsB,GAAG,MAClCC,UADkC,IAEjC;AAAA;;AACD;AACA,QAAMC,UAAU,GAAG,IAAIN,UAAJ,CAAe,gCAAf,CAAnB,CAFC,CAGD;;AACA,QAAMO,QAAQ,GAAG,MAAMJ,YAAY,CAACK,uBAAb,CAAqCF,UAArC,EAAiDD,UAAjD,CAAvB,CAJC,CAKD;;AACA,QAAMI,kBAAkB,GAAGF,QAAQ,CAChCG,GADwB,CACpB;AAAA,QAAC;AAAEC,MAAAA;AAAF,KAAD;AAAA,WAAcA,IAAd;AAAA,GADoB,EAExBC,MAFwB,CAEjB;AAAA,QAAC;AAAEC,MAAAA;AAAF,KAAD;AAAA,WAAgB,CAAAA,MAAM,SAAN,IAAAA,MAAM,WAAN,YAAAA,MAAM,CAAEC,QAAR,MAAqB,CAArC;AAAA,GAFiB,CAA3B,CANC,CAUD;;AACA,MAAIC,gBAAgB,GAAGN,kBAAkB,CAACC,GAAnB,CAAuB;AAAA,QAAC;AAAEM,MAAAA;AAAF,KAAD;AAAA,WAAcA,IAAd;AAAA,GAAvB,CAAvB;AAEA,MAAIC,oBAAoB,GAAG,EAA3B;AACA,MAAIC,SAAJ,CAdC,CAgBD;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGJ,gBAAgB,CAACK,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;AAC7C;AACAF,IAAAA,oBAAoB,CAACE,CAAD,CAApB,GAA0B,MAAME,aAAa,CAACN,gBAAgB,CAACI,CAAD,CAAjB,CAA7C,CAF6C,CAI7C;AACA;;AACAD,IAAAA,SAAS,GAAG,MAAMZ,UAAU,CAACgB,uBAAX,CACdL,oBADc,EAEd,WAFc,CAAlB;AAIH;;AAED,MAAIM,qBAAqB,iBAAGL,SAAH,+CAAG,WAAWR,GAAX,CACvBc,IAAD,IAAU,CAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,YAAAA,IAAI,CAAEb,IAAN,MAAec,SAAf,GAA2BvB,YAAY,CAACwB,WAAb,CAAyBF,IAAzB,aAAyBA,IAAzB,uBAAyBA,IAAI,CAAEb,IAA/B,CAA3B,GAAkEc,SADpD,EAE1Bb,MAF0B,CAEnB,UAAUe,OAAV,EAAoB;AACzB,WAAOA,OAAO,KAAKF,SAAnB;AACF,GAJ0B,CAA5B;AAMAG,EAAAA,OAAO,CAACC,GAAR,CAAYN,qBAAZ;AACA,SAAOA,qBAAP;AACH,CAvCM;AAyCP,OAAO,eAAeF,aAAf,CAA6BS,UAA7B,EAAoD;AACvD,QAAMC,cAAc,GAAGC,MAAM,CAACC,IAAP,CAAY,UAAZ,CAAvB;AACA,QAAMC,0BAA0B,GAAG,IAAInC,SAAJ,CAC/B,6CAD+B,CAAnC,CAFuD,CAMvD;;AACA,QAAMoC,eAAe,GAAG,CACpB,MAAMpC,SAAS,CAACqC,kBAAV,CACF,CACIL,cADJ,EAEIG,0BAA0B,CAACG,QAA3B,EAFJ,EAGIP,UAAU,CAACO,QAAX,EAHJ,CADE,EAMFH,0BANE,CADc,EAStB,CATsB,CAAxB;AAWAN,EAAAA,OAAO,CAACC,GAAR,CAAYM,eAAZ;AACA,SAAOA,eAAP;AACH","sourcesContent":["import {  programs } from '@metaplex/js/';\nimport { PublicKey, Connection } from '@solana/web3.js';\nimport { web3 } from '@project-serum/anchor';\n\nconst {\n    metadata: { MetadataData },\n    TokenAccount,\n} = programs;\n\nexport const fetchNFTsOwnedByWallet = async(\n    userWallet : web3.PublicKey\n) => {\n    //Establishes Connection\n    const connection = new Connection(\"https://api.devnet.solana.com/\");\n    // Gets array of token account objects\n    const accounts = await TokenAccount.getTokenAccountsByOwner(connection, userWallet);\n    // Isolate accounts with a positive balance\n    const accountsWithAmount = accounts\n      .map(({ data }) => data)\n      .filter(({ amount }) => amount?.toNumber() > 0);\n\n    // Fetches mint address within token account\n    let nftMintAddresses = accountsWithAmount.map(({ mint }) => mint);\n\n    let nftMetadataAddresses = [];\n    let nftAcInfo;\n\n    // Loop thru array of token mint addresses\n    for(let i = 0; i < nftMintAddresses.length; i++) {\n        // Gets PDA (metadata address) for each token account\n        nftMetadataAddresses[i] = await fetchMetadata(nftMintAddresses[i]);\n\n        // Gets Account object from PDA (metadata address)\n        // getMultipleAccountsInfo handles an array of Accounts\n        nftAcInfo = await connection.getMultipleAccountsInfo(\n            nftMetadataAddresses,\n            \"processed\"\n        );\n    }\n\n    let nftAcInfoDeserialized = nftAcInfo?.map(\n        (info) => info?.data !== undefined ? MetadataData.deserialize(info?.data) : undefined\n    ).filter(function( element ) {\n        return element !== undefined;\n     });\n    \n    console.log(nftAcInfoDeserialized)\n    return nftAcInfoDeserialized;\n}\n\nexport async function fetchMetadata(nftMintKey: PublicKey) {\n    const metadataBuffer = Buffer.from('metadata');\n    const metadataProgramIdPublicKey = new PublicKey(\n        'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'\n    );\n\n    // Fetches metadata account from PDA\n    const metadataAccount = (\n        await PublicKey.findProgramAddress(\n            [\n                metadataBuffer,\n                metadataProgramIdPublicKey.toBuffer(),\n                nftMintKey.toBuffer(),\n            ],\n            metadataProgramIdPublicKey\n        )\n    )[0];\n\n    console.log(metadataAccount)\n    return metadataAccount;\n}"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import * as anchor from \"@project-serum/anchor\";\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport { abort } from \"process\";\nconst connection = new anchor.web3.Connection(\"https://api.devnet.solana.com\", \"confirmed\");\nconst METADATA_PREFIX = \"metadata\";\nconst METADATA_PROGRAM_ID = \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\";\n\nconst loadMintData = walletAddress => {\n  let tokenAddresses = getTokenAddressesInWallet(walletAddress);\n  let tokenData = getMultipleTokenData(tokenAddresses.slice(0, 32));\n  let tokens = [];\n\n  for (let {\n    data\n  } of tokenData.filter(e => e)) {\n    const mint = decodeMetadata(data[0]);\n    console.log(mint);\n  }\n};\n\nasync function getTokenAddressesInWallet(walletAddress) {\n  let response = await connection._rpcRequest(\"getTokenAccountsByOwner\", [walletAddress, {\n    programId: \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n  }, {\n    encoding: \"base64\",\n    dataSlice: {\n      offset: 0,\n      length: 32\n    }\n  }]).then(e => e.result.value);\n  return response.map(e => PublicKey.from(stringToBuffer(atob(e.account.data[0]))).toString());\n}\n\nasync function getMultipleTokenData(tokens, from = 0, to = tokens.length) {\n  let metadataAddresses = [];\n\n  for (let i = from; i < to; i++) metadataAddresses[i] = await getMetadataAddress(tokens[i]);\n\n  return connection._rpcRequest(\"getMultipleAccounts\", [metadataAddresses, {\n    encoding: \"base64\"\n  }]).then(e => e.result.value);\n}\n\nasync function decodeMetadata(dataBase64) {\n  let metadataUri = atob(dataBase64).match(/https?:\\/\\/.*?(?=\\0)/);\n  if (!metadataUri) return null;\n  return fetch(metadataUri).then(e => e.json());\n}\n\nasync function getMetadataAddress(tokenAddress) {\n  let metadataProgramIdKey = PublicKey.from(METADATA_PROGRAM_ID);\n  let [address, nonce] = await PublicKey.findProgramAddress([stringToBuffer(METADATA_PREFIX), metadataProgramIdKey.toBuffer(), PublicKey.from(tokenAddress).toBuffer()], metadataProgramIdKey);\n  return address.toBase58();\n}\n\nfunction stringToBuffer(string) {\n  return Uint8Array.from(string, e => e.charCodeAt(0));\n}\n\nexport default loadMintData;","map":{"version":3,"sources":["/Users/drewriester/Coding/Solana/upgrade-nft/src/metadata/connect-wallet.js"],"names":["anchor","TOKEN_PROGRAM_ID","Connection","PublicKey","abort","connection","web3","METADATA_PREFIX","METADATA_PROGRAM_ID","loadMintData","walletAddress","tokenAddresses","getTokenAddressesInWallet","tokenData","getMultipleTokenData","slice","tokens","data","filter","e","mint","decodeMetadata","console","log","response","_rpcRequest","programId","encoding","dataSlice","offset","length","then","result","value","map","from","stringToBuffer","atob","account","toString","to","metadataAddresses","i","getMetadataAddress","dataBase64","metadataUri","match","fetch","json","tokenAddress","metadataProgramIdKey","address","nonce","findProgramAddress","toBuffer","toBase58","string","Uint8Array","charCodeAt"],"mappings":"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","sourcesContent":["import * as anchor from \"@project-serum/anchor\";\r\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\r\nimport { Connection, PublicKey } from \"@solana/web3.js\";\r\nimport { abort } from \"process\";\r\n\r\nconst connection = new anchor.web3.Connection(\r\n\t\"https://api.devnet.solana.com\",\r\n\t\"confirmed\"\r\n)\r\n\r\nconst METADATA_PREFIX = \"metadata\";\r\nconst METADATA_PROGRAM_ID = \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\";\r\n\r\n\r\nconst loadMintData = (walletAddress) => {\r\n\tlet tokenAddresses = getTokenAddressesInWallet(walletAddress);\r\n\tlet tokenData = getMultipleTokenData(tokenAddresses.slice(0, 32));\r\n\tlet tokens = [];\r\n\tfor(let { data } of tokenData.filter(e => e)) {\r\n\t\tconst mint = decodeMetadata(data[0])\t\r\n\t\tconsole.log(mint)\r\n\t}\r\n}\r\n\r\nasync function getTokenAddressesInWallet(walletAddress){\r\n\tlet response = await connection._rpcRequest(\r\n\t\t\"getTokenAccountsByOwner\",\r\n\t\t[\r\n\t\t\twalletAddress,\r\n\t\t\t{ programId: \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\" },\r\n\t\t\t{\r\n\t\t\t\tencoding: \"base64\",\r\n\t\t\t\tdataSlice: { offset: 0, length: 32 }\r\n\t\t\t}\r\n\t\t]\r\n\t).then(e => e.result.value);\r\n\t\r\n\treturn response.map(e =>\r\n\t\tPublicKey.from(stringToBuffer(atob(e.account.data[0]))).toString()\r\n\t)\r\n}\r\n\r\nasync function getMultipleTokenData(tokens, from = 0, to = tokens.length){\r\n\tlet metadataAddresses = [];\r\n\tfor(let i = from; i < to; i++)\r\n\t\tmetadataAddresses[i] = await getMetadataAddress(tokens[i]);\r\n\t\r\n\treturn connection._rpcRequest(\r\n\t\t\"getMultipleAccounts\",\r\n\t\t[\r\n\t\t\tmetadataAddresses,\r\n\t\t\t{ encoding: \"base64\" }\r\n\t\t]\r\n\t).then(e => e.result.value);\r\n}\r\n\r\nasync function decodeMetadata(dataBase64){\r\n\tlet metadataUri = atob(dataBase64).match(/https?:\\/\\/.*?(?=\\0)/);\r\n\tif(!metadataUri)\r\n\t\treturn null;\r\n\treturn fetch(metadataUri).then(e => e.json());\r\n}\r\n\r\nasync function getMetadataAddress(tokenAddress){\r\n\tlet metadataProgramIdKey = PublicKey.from(METADATA_PROGRAM_ID);\r\n\tlet [address, nonce] = await PublicKey.findProgramAddress(\r\n\t\t[\r\n\t\t\tstringToBuffer(METADATA_PREFIX),\r\n\t\t\tmetadataProgramIdKey.toBuffer(),\r\n\t\t\tPublicKey.from(tokenAddress).toBuffer()\r\n\t\t],\r\n\t\tmetadataProgramIdKey\r\n    );\r\n\t\r\n\treturn address.toBase58();\r\n}\r\n\r\nfunction stringToBuffer(string){\r\n\treturn Uint8Array.from(string, e => e.charCodeAt(0));\r\n}\r\n\r\nexport default loadMintData"]},"metadata":{},"sourceType":"module"}
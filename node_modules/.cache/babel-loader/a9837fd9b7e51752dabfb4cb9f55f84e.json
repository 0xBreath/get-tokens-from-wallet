{"ast":null,"code":"import * as anchor from \"@project-serum/anchor\";\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { URL, Connection } from \"@solana/web3.js\";\nimport { abort } from \"process\";\nconst connection = new anchor.web3.Connection(\"https://api.devnet.solana.com\", \"confirmed\");\nconst METADATA_PREFIX = \"metadata\";\nconst METADATA_PROGRAM_ID = \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\";\n\nconst loadMintData = walletAddress => {\n  let tokenAddresses = getTokenAddressesInWallet(walletAddress);\n  let tokenData = getMultipleTokenData(tokenAddresses.slice(0, 32));\n  let tokens = [];\n\n  for (let {\n    data\n  } of tokenData.filter(e => e)) {\n    const mint = decodeMetadata(data[0]);\n    console.log(mint);\n  }\n};\n\nasync function getTokenAddressesInWallet(walletAddress) {\n  let response = await connection._rpcRequest(\"getTokenAccountsByOwner\", [walletAddress, {\n    programId: \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n  }, {\n    encoding: \"base64\",\n    dataSlice: {\n      offset: 0,\n      length: 32\n    }\n  }]).then(e => e.result.value);\n  return response.map(e => PublicKey.from(stringToBuffer(atob(e.account.data[0]))).toString());\n}\n\nasync function getMultipleTokenData(tokens, from = 0, to = tokens.length) {\n  let metadataAddresses = [];\n\n  for (let i = from; i < to; i++) metadataAddresses[i] = await getMetadataAddress(tokens[i]);\n\n  return connection._rpcRequest(\"getMultipleAccounts\", [metadataAddresses, {\n    encoding: \"base64\"\n  }]).then(e => e.result.value);\n}\n\nasync function decodeMetadata(dataBase64) {\n  let metadataUri = atob(dataBase64).match(/https?:\\/\\/.*?(?=\\0)/);\n  if (!metadataUri) return null;\n  return fetch(metadataUri).then(e => e.json());\n}\n\nasync function getMetadataAddress(tokenAddress) {\n  let metadataProgramIdKey = PublicKey.from(METADATA_PROGRAM_ID);\n  let [address, nonce] = await PublicKey.findProgramAddress([stringToBuffer(METADATA_PREFIX), metadataProgramIdKey.toBuffer(), PublicKey.from(tokenAddress).toBuffer()], metadataProgramIdKey);\n  return address.toBase58();\n}\n\nconst PublicKey = solanaWeb3.PublicKey;\nconst PUBLIC_KEY_CACHE = {};\n\nPublicKey.from = input => {\n  let publicKey = null;\n  if (typeof input == \"string\" || input instanceof Uint8Array) publicKey = new PublicKey(input);else throw new Error(`Could not create PublicKey from: \"${input}\"`);\n  key = publicKey.toBase58();\n  if (!(key in PUBLIC_KEY_CACHE)) PUBLIC_KEY_CACHE[key] = publicKey;\n  return PUBLIC_KEY_CACHE[key];\n};\n\nfunction stringToBuffer(string) {\n  return Uint8Array.from(string, e => e.charCodeAt(0));\n}\n\nexport default loadMintData;","map":{"version":3,"sources":["/Users/drewriester/Coding/Solana/upgrade-nft/src/metadata/connect-wallet.js"],"names":["anchor","TOKEN_PROGRAM_ID","URL","Connection","abort","connection","web3","METADATA_PREFIX","METADATA_PROGRAM_ID","loadMintData","walletAddress","tokenAddresses","getTokenAddressesInWallet","tokenData","getMultipleTokenData","slice","tokens","data","filter","e","mint","decodeMetadata","console","log","response","_rpcRequest","programId","encoding","dataSlice","offset","length","then","result","value","map","PublicKey","from","stringToBuffer","atob","account","toString","to","metadataAddresses","i","getMetadataAddress","dataBase64","metadataUri","match","fetch","json","tokenAddress","metadataProgramIdKey","address","nonce","findProgramAddress","toBuffer","toBase58","solanaWeb3","PUBLIC_KEY_CACHE","input","publicKey","Uint8Array","Error","key","string","charCodeAt"],"mappings":"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","sourcesContent":["import * as anchor from \"@project-serum/anchor\";\r\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\r\nimport {\r\n    URL,\r\n    Connection,\r\n  } from \"@solana/web3.js\";\r\nimport { abort } from \"process\";\r\n\r\nconst connection = new anchor.web3.Connection(\r\n\t\"https://api.devnet.solana.com\",\r\n\t\"confirmed\"\r\n)\r\n\r\nconst METADATA_PREFIX = \"metadata\";\r\nconst METADATA_PROGRAM_ID = \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\";\r\n\r\n\r\nconst loadMintData = (walletAddress) => {\r\n\tlet tokenAddresses = getTokenAddressesInWallet(walletAddress);\r\n\tlet tokenData = getMultipleTokenData(tokenAddresses.slice(0, 32));\r\n\tlet tokens = [];\r\n\tfor(let { data } of tokenData.filter(e => e)) {\r\n\t\tconst mint = decodeMetadata(data[0])\t\r\n\t\tconsole.log(mint)\r\n\t}\r\n}\r\n\r\nasync function getTokenAddressesInWallet(walletAddress){\r\n\tlet response = await connection._rpcRequest(\r\n\t\t\"getTokenAccountsByOwner\",\r\n\t\t[\r\n\t\t\twalletAddress,\r\n\t\t\t{ programId: \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\" },\r\n\t\t\t{\r\n\t\t\t\tencoding: \"base64\",\r\n\t\t\t\tdataSlice: { offset: 0, length: 32 }\r\n\t\t\t}\r\n\t\t]\r\n\t).then(e => e.result.value);\r\n\t\r\n\treturn response.map(e =>\r\n\t\tPublicKey.from(stringToBuffer(atob(e.account.data[0]))).toString()\r\n\t)\r\n}\r\n\r\nasync function getMultipleTokenData(tokens, from = 0, to = tokens.length){\r\n\tlet metadataAddresses = [];\r\n\tfor(let i = from; i < to; i++)\r\n\t\tmetadataAddresses[i] = await getMetadataAddress(tokens[i]);\r\n\t\r\n\treturn connection._rpcRequest(\r\n\t\t\"getMultipleAccounts\",\r\n\t\t[\r\n\t\t\tmetadataAddresses,\r\n\t\t\t{ encoding: \"base64\" }\r\n\t\t]\r\n\t).then(e => e.result.value);\r\n}\r\n\r\nasync function decodeMetadata(dataBase64){\r\n\tlet metadataUri = atob(dataBase64).match(/https?:\\/\\/.*?(?=\\0)/);\r\n\tif(!metadataUri)\r\n\t\treturn null;\r\n\treturn fetch(metadataUri).then(e => e.json());\r\n}\r\n\r\nasync function getMetadataAddress(tokenAddress){\r\n\tlet metadataProgramIdKey = PublicKey.from(METADATA_PROGRAM_ID);\r\n\tlet [address, nonce] = await PublicKey.findProgramAddress(\r\n\t\t[\r\n\t\t\tstringToBuffer(METADATA_PREFIX),\r\n\t\t\tmetadataProgramIdKey.toBuffer(),\r\n\t\t\tPublicKey.from(tokenAddress).toBuffer()\r\n\t\t],\r\n\t\tmetadataProgramIdKey\r\n    );\r\n\t\r\n\treturn address.toBase58();\r\n}\r\n\r\nconst PublicKey = solanaWeb3.PublicKey;\r\nconst PUBLIC_KEY_CACHE = {};\r\nPublicKey.from = (input) => {\r\n\tlet publicKey = null;\r\n\tif(typeof input == \"string\" || input instanceof Uint8Array)\r\n\t\tpublicKey = new PublicKey(input);\r\n\telse\r\n\t\tthrow new Error(`Could not create PublicKey from: \"${input}\"`);\r\n\t\r\n\tkey = publicKey.toBase58();\r\n\tif(!(key in PUBLIC_KEY_CACHE))\r\n\t\tPUBLIC_KEY_CACHE[key] = publicKey;\r\n\treturn PUBLIC_KEY_CACHE[key];\r\n}\r\n\r\nfunction stringToBuffer(string){\r\n\treturn Uint8Array.from(string, e => e.charCodeAt(0));\r\n}\r\n\r\nexport default loadMintData"]},"metadata":{},"sourceType":"module"}
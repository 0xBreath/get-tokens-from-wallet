{"ast":null,"code":"import { programs } from '@metaplex/js/';\nimport { PublicKey, Connection } from '@solana/web3.js';\nconst {\n  metadata: {\n    MetadataData\n  },\n  TokenAccount\n} = programs;\n\nconst fetchMintArray = async userWallet => {\n  var _nftAcInfo;\n\n  //Establishes Connection\n  const connection = new Connection(\"https://api.devnet.solana.com/\"); // Gets array of token account objects\n\n  const accounts = await TokenAccount.getTokenAccountsByOwner(connection, userWallet); // Isolate accounts with a positive balance\n\n  const accountsWithAmount = accounts.map(_ref => {\n    let {\n      data\n    } = _ref;\n    return data;\n  }).filter(_ref2 => {\n    let {\n      amount\n    } = _ref2;\n    return (amount === null || amount === void 0 ? void 0 : amount.toNumber()) > 0;\n  }); // Fetches mint address within token account\n\n  let nftMintAddresses = accountsWithAmount.map(_ref3 => {\n    let {\n      mint\n    } = _ref3;\n    return mint;\n  });\n  let nftMetadataAddresses = [];\n  let nftAcInfo; // Loop thru array of token mint addresses\n\n  for (let i = 0; i < nftMintAddresses.length; i++) {\n    // Gets PDA (metadata address) for each token account\n    nftMetadataAddresses[i] = await fetchMetadata(nftMintAddresses[i]); // Gets Account object from PDA (metadata address)\n    // getMultipleAccountsInfo handles an array of Accounts\n\n    nftAcInfo = await connection.getMultipleAccountsInfo(nftMetadataAddresses, \"processed\");\n  } // nftAccountInfo stores metadata account -> object with attributes\n\n\n  let nftAccountInfo = (_nftAcInfo = nftAcInfo) === null || _nftAcInfo === void 0 ? void 0 : _nftAcInfo.map(info => (info === null || info === void 0 ? void 0 : info.data) !== undefined ? MetadataData.deserialize(info === null || info === void 0 ? void 0 : info.data) : undefined).filter(function (element) {\n    return element !== undefined;\n  });\n  /*\n      Isolate specific attributes within nftAccountInfo \n      By referencing any of these attributes\n       key: MetadataKey;\n      updateAuthority: StringPublicKey;\n      mint: StringPublicKey;\n      data: MetadataDataData;\n      primarySaleHappened: boolean;\n      isMutable: boolean;\n      editionNonce: number | null;\n  */\n  // My program needs the token mint addresses\n  // Customize your program by changing \".mint\"\n  // to any of the object attributes abpve\n\n  let mintArray = [];\n\n  if (nftAccountInfo) {\n    for (let k = 0; k < nftAccountInfo.length; k++) {\n      mintArray[k] = nftAccountInfo[k].mint;\n    }\n  }\n\n  console.log(nftAccountInfo);\n  console.log(mintArray);\n  return nftAccountInfo;\n};\n\nexport async function fetchMetadata(nftMintKey) {\n  const metadataBuffer = Buffer.from('metadata');\n  const metadataProgramIdPublicKey = new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'); // Fetches metadata account from PDA\n\n  const metadataAccount = (await PublicKey.findProgramAddress([metadataBuffer, metadataProgramIdPublicKey.toBuffer(), nftMintKey.toBuffer()], metadataProgramIdPublicKey))[0];\n  console.log(metadataAccount);\n  return metadataAccount;\n}\nexport default fetchMintArray;","map":{"version":3,"sources":["/Users/drewriester/Coding/Solana/upgrade-nft/src/components/fetchMeta.ts"],"names":["programs","PublicKey","Connection","metadata","MetadataData","TokenAccount","fetchMintArray","userWallet","connection","accounts","getTokenAccountsByOwner","accountsWithAmount","map","data","filter","amount","toNumber","nftMintAddresses","mint","nftMetadataAddresses","nftAcInfo","i","length","fetchMetadata","getMultipleAccountsInfo","nftAccountInfo","info","undefined","deserialize","element","mintArray","k","console","log","nftMintKey","metadataBuffer","Buffer","from","metadataProgramIdPublicKey","metadataAccount","findProgramAddress","toBuffer"],"mappings":"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","sourcesContent":["import {  programs } from '@metaplex/js/';\nimport { PublicKey, Connection } from '@solana/web3.js';\nimport { web3 } from '@project-serum/anchor';\n\nconst {\n    metadata: { MetadataData },\n    TokenAccount,\n} = programs;\n\nconst fetchMintArray = async(\n    userWallet : web3.PublicKey\n) => {\n    //Establishes Connection\n    const connection = new Connection(\"https://api.devnet.solana.com/\");\n    // Gets array of token account objects\n    const accounts = await TokenAccount.getTokenAccountsByOwner(connection, userWallet);\n    // Isolate accounts with a positive balance\n    const accountsWithAmount = accounts\n      .map(({ data }) => data)\n      .filter(({ amount }) => amount?.toNumber() > 0);\n\n    // Fetches mint address within token account\n    let nftMintAddresses = accountsWithAmount.map(({ mint }) => mint);\n\n    let nftMetadataAddresses = [];\n    let nftAcInfo;\n\n    // Loop thru array of token mint addresses\n    for(let i = 0; i < nftMintAddresses.length; i++) {\n        // Gets PDA (metadata address) for each token account\n        nftMetadataAddresses[i] = await fetchMetadata(nftMintAddresses[i]);\n\n        // Gets Account object from PDA (metadata address)\n        // getMultipleAccountsInfo handles an array of Accounts\n        nftAcInfo = await connection.getMultipleAccountsInfo(\n            nftMetadataAddresses,\n            \"processed\"\n        );\n    }\n\n    // nftAccountInfo stores metadata account -> object with attributes\n    let nftAccountInfo = nftAcInfo?.map(\n        (info) => info?.data !== undefined ? MetadataData.deserialize(info?.data) : undefined\n    ).filter(function( element ) {\n        return element !== undefined;\n     });\n    \n    /*\n        Isolate specific attributes within nftAccountInfo \n        By referencing any of these attributes\n\n        key: MetadataKey;\n        updateAuthority: StringPublicKey;\n        mint: StringPublicKey;\n        data: MetadataDataData;\n        primarySaleHappened: boolean;\n        isMutable: boolean;\n        editionNonce: number | null;\n    */\n    // My program needs the token mint addresses\n    // Customize your program by changing \".mint\"\n    // to any of the object attributes abpve\n    let mintArray = []\n    if (nftAccountInfo) {\n        for (let k = 0; k < nftAccountInfo.length; k++) {\n            mintArray[k] = nftAccountInfo[k].mint\n        }\n    } \n    \n    console.log(nftAccountInfo)\n    console.log(mintArray)\n    return nftAccountInfo;\n}\n\nexport async function fetchMetadata(nftMintKey: PublicKey) {\n    const metadataBuffer = Buffer.from('metadata');\n    const metadataProgramIdPublicKey = new PublicKey(\n        'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'\n    );\n\n    // Fetches metadata account from PDA\n    const metadataAccount = (\n        await PublicKey.findProgramAddress(\n            [\n                metadataBuffer,\n                metadataProgramIdPublicKey.toBuffer(),\n                nftMintKey.toBuffer(),\n            ],\n            metadataProgramIdPublicKey\n        )\n    )[0];\n\n    console.log(metadataAccount)\n    return metadataAccount;\n}\n\nexport default fetchMintArray"]},"metadata":{},"sourceType":"module"}